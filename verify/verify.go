// Copyright (c) 2019, Mohlmann Solutions SRL. All rights reserved.
// Use of this source code is governed by a License that can be found in the LICENSE file.
// SPDX-License-Identifier: BSD-3-Clause

/*
Package verify provides middleware for GRPc servers which need
to verify JSON Web Tokens generated by this Authenticator service.
*/
package verify

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"strconv"
	"strings"
	"sync"
	"time"

	pb "github.com/moapis/authenticator/pb"
	"github.com/pascaldekloe/jwt"
)

// VerificationErr type for errors generated by this package.
type VerificationErr struct {
	name string
	err  error
}

// Unwrap returns the originating error
func (e *VerificationErr) Unwrap() error { return e.err }
func (e *VerificationErr) Error() string { return fmt.Sprint(e.name, ": ", e.err) }

const errHeader = "JWT header"

// ParseJWTHeader checks is the Alg field is supported and returns the Kid as an int.
func ParseJWTHeader(token string) (int, error) {
	js, err := base64.RawURLEncoding.DecodeString(strings.Split(token, ".")[0])
	if err != nil {
		return 0, &VerificationErr{errHeader, err}
	}

	var h struct {
		Alg string // algorithm
		Kid string // key identifier
	}
	if err := json.Unmarshal(js, &h); err != nil {
		return 0, &VerificationErr{errHeader, err}
	}
	if h.Alg != jwt.EdDSA {
		return 0, &VerificationErr{errHeader, fmt.Errorf("Unsupported algoritm: %s", h.Alg)}
	}
	kid, err := strconv.ParseInt(h.Kid, 10, 32)
	if err != nil {
		return 0, &VerificationErr{errHeader, err}
	}
	return int(kid), nil
}

// Verificator holds public keys, which are used to verify tokens.
// Public keys that are not found in the local cache, are retrieved
// through an gRPC call from an Authenticator server.
type Verificator struct {
	Client pb.AuthenticatorClient
	keys   map[int32][]byte
	mtx    sync.RWMutex
}

// Get key from cache
func (v *Verificator) get(kid int32) (key []byte, ok bool) {
	v.mtx.RLock()
	key, ok = v.keys[kid]
	v.mtx.RUnlock()
	return key, ok
}

// Set key to cache. Existing key with same ID will be overwritten.
func (v *Verificator) set(kid int32, key []byte) {
	v.mtx.Lock()
	if v.keys == nil {
		v.keys = make(map[int32][]byte)
	}
	v.keys[kid] = key
	v.mtx.Unlock()
}

// RetrieveError in case of gRPC client errors.
type RetrieveError struct {
	VerificationErr
}

const errRetrieval = "Key retrieval"

// Retrieve a key over gRPC Client.
// After succesful retrieval, the key is Set to the cache
func (v *Verificator) retrieve(ctx context.Context, kid int32) ([]byte, error) {
	pkl, err := v.Client.GetPubKey(ctx, &pb.KeyID{Kid: kid})
	if err != nil {
		return nil, &RetrieveError{VerificationErr{errRetrieval, err}}
	}
	key := pkl.GetKey()
	if key == nil {
		err = fmt.Errorf("Key ID %v not found", kid)
		return nil, &VerificationErr{errRetrieval, err}
	}
	v.set(kid, key)
	return key, nil
}

func (v *Verificator) getOrRetrieve(ctx context.Context, kid int32) ([]byte, error) {
	if key, ok := v.get(kid); ok {
		return key, nil
	}
	return v.retrieve(ctx, kid)
}

// Token verifies the passed JSON web token and checks validity (like expiry).
// If the key is not in the cache, it will be fetched through the client before checking.
// Typical errors can by of grpc/status or Verfication errors.
func (v *Verificator) Token(ctx context.Context, token string) (*jwt.Claims, error) {
	kid, err := ParseJWTHeader(token)
	if err != nil {
		return nil, err
	}
	key, err := v.getOrRetrieve(ctx, int32(kid))
	if err != nil {
		return nil, err
	}
	claims, err := jwt.EdDSACheck([]byte(token), key)
	if err != nil {
		return nil, &VerificationErr{"EdDSACheck", err}
	}
	if !claims.Valid(time.Now()) {
		return nil, &VerificationErr{"Token invalid", fmt.Errorf(
			"Issued: %v; NotBefore %v, Expires %v",
			claims.Issued.Time(),
			claims.NotBefore.Time(),
			claims.Expires.Time(),
		)}
	}
	return claims, nil
}

/*
// Audiences matches the JWT claims' intended audiances and service name(s).
// At least one of the Claim's audiences should match one of the names.
func Audiences(claims *jwt.Claims, names []string) error {
	for _, aud := range claims.Audiences {
		for _, r := range names {
			if r == aud {
				return nil
			}
		}
	}
	return status.VerificationErr(codes.PermissionDenied, ErrAudience)
}

// MethodGroups contains method names as first index and allowed user groups as second index.
// The string can be used to pass Group names for logging and reporting purposses.
type MethodGroups map[string]map[int]string

// Groups are matched between method and `group_ids` field in the Claims.
// The `group_ids` field should be contain []int representing this user's group roles.
// At least one of the Claim's `group_ids` should match the method's groups.
// If groups is nil, group matching is skipped and considered succesfull.
// If a method has group ID 0 defined,
// it is considered available for any request with a valid token. (for example all users)
func Groups(method string, mg MethodGroups) {

}
*/
