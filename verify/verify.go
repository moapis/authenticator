// Copyright (c) 2019, Mohlmann Solutions SRL. All rights reserved.
// Use of this source code is governed by a License that can be found in the LICENSE file.
// SPDX-License-Identifier: BSD-3-Clause

/*
Package verify provides middleware for GRPc servers which need
to verify JSON Web Tokens generated by this Authenticator service.
*/
package verify

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"strconv"
	"strings"
	"sync"
	"time"

	auth "github.com/moapis/authenticator"
	"github.com/pascaldekloe/jwt"
)

// VerificationErr type for errors generated by this package.
type VerificationErr struct {
	name string
	err  error
}

// Unwrap returns the originating error
func (e *VerificationErr) Unwrap() error { return e.err }
func (e *VerificationErr) Error() string { return fmt.Sprint(e.name, ": ", e.err) }

const errHeader = "JWT header"

// ParseJWTHeader checks is the Alg field is supported and returns the Kid as an int.
func ParseJWTHeader(token string) (int, error) {
	js, err := base64.RawURLEncoding.DecodeString(strings.Split(token, ".")[0])
	if err != nil {
		return 0, &VerificationErr{errHeader, err}
	}

	var h struct {
		Alg string // algorithm
		Kid string // key identifier
	}
	if err := json.Unmarshal(js, &h); err != nil {
		return 0, &VerificationErr{errHeader, err}
	}
	if h.Alg != jwt.EdDSA {
		return 0, &VerificationErr{errHeader, fmt.Errorf("Unsupported algoritm: %s", h.Alg)}
	}
	kid, err := strconv.ParseInt(h.Kid, 10, 32)
	if err != nil {
		return 0, &VerificationErr{errHeader, err}
	}
	return int(kid), nil
}

// Verificator holds public keys, which are used to verify tokens.
// Public keys that are not found in the local cache, are retrieved
// through an gRPC call from an Authenticator server.
type Verificator struct {
	Client auth.AuthenticatorClient
	// Audiences that are accepted.
	// Nil accepts all.
	Audiences []string
	keys      map[int32][]byte
	mtx       sync.RWMutex
}

// Get key from cache
func (v *Verificator) get(kid int32) (key []byte, ok bool) {
	v.mtx.RLock()
	key, ok = v.keys[kid]
	v.mtx.RUnlock()
	return key, ok
}

// Set key to cache. Existing key with same ID will be overwritten.
func (v *Verificator) set(kid int32, key []byte) {
	v.mtx.Lock()
	if v.keys == nil {
		v.keys = make(map[int32][]byte)
	}
	v.keys[kid] = key
	v.mtx.Unlock()
}

// RetrieveError in case of gRPC client errors.
type RetrieveError struct {
	VerificationErr
}

const errRetrieval = "Key retrieval"

// Retrieve a key over gRPC Client.
// After succesful retrieval, the key is Set to the cache
func (v *Verificator) retrieve(ctx context.Context, kid int32) ([]byte, error) {
	pkl, err := v.Client.GetPubKey(ctx, &auth.KeyID{Kid: kid})
	if err != nil {
		return nil, &RetrieveError{VerificationErr{errRetrieval, err}}
	}
	key := pkl.GetKey()
	if key == nil {
		err = fmt.Errorf("Key ID %v not found", kid)
		return nil, &VerificationErr{errRetrieval, err}
	}
	v.set(kid, key)
	return key, nil
}

func (v *Verificator) getOrRetrieve(ctx context.Context, kid int32) ([]byte, error) {
	if key, ok := v.get(kid); ok {
		return key, nil
	}
	return v.retrieve(ctx, kid)
}

// Token verifies the passed JSON web token and checks validity (like expiry).
// If the key is not in the cache, it will be fetched through the client before checking.
// Typical errors can by of grpc/status or Verfication errors.
func (v *Verificator) Token(ctx context.Context, token string) (*jwt.Claims, error) {
	kid, err := ParseJWTHeader(token)
	if err != nil {
		return nil, err
	}
	key, err := v.getOrRetrieve(ctx, int32(kid))
	if err != nil {
		return nil, err
	}
	claims, err := jwt.EdDSACheck([]byte(token), key)
	if err != nil {
		return nil, &VerificationErr{"EdDSACheck", err}
	}
	if !claims.Valid(time.Now()) {
		return nil, &VerificationErr{"Token invalid", fmt.Errorf(
			"Issued: %v; NotBefore %v; Expires %v",
			claims.Issued.Time(),
			claims.NotBefore.Time(),
			claims.Expires.Time(),
		)}
	}
	if v.Audiences != nil && !HasAnyEntry(v.Audiences, claims.Audiences) {
		return nil, &VerificationErr{"Required audience not found", fmt.Errorf(
			"Accepted: %v; Claimed: %v",
			v.Audiences,
			claims.Audiences,
		)}
	}
	return claims, nil
}

// HasAnyEntry is a utility function, which compares slice A and B.
// It returns true if one or more entries is present in both A and B or when both are nil.
func HasAnyEntry(a, b []string) bool {
	if a == nil && b == nil {
		return true
	}

	for _, av := range a {
		for _, bv := range b {
			if av == bv {
				return true
			}
		}
	}
	return false
}
