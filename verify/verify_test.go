// Copyright (c) 2019, Mohlmann Solutions SRL. All rights reserved.
// Use of this source code is governed by a License that can be found in the LICENSE file.
// SPDX-License-Identifier: BSD-3-Clause

/*
Package verify provides middleware for GRPc servers which need
to verify JSON Web Tokens generated by this Authenticator service.
*/
package verify

import (
	"bytes"
	"context"
	"encoding/base64"
	"errors"
	"fmt"
	"reflect"
	"testing"
	"time"

	"github.com/pascaldekloe/jwt"
)

const (
	testKeyInput = "qwertyuiopasdfghjklzxcvbnm123456"
	testPrivKey  = "qwertyuiopasdfghjklzxcvbnm123456\xda\xf9W\x14\xfcc\xe2\xe5\x1b+i\xa3\n\xbek($\x1e\x18\xc6j/*\x88\xaf\xa7X݉|ֳ"
	testPubKey   = "\xda\xf9W\x14\xfcc\xe2\xe5\x1b+i\xa3\n\xbek($\x1e\x18\xc6j/*\x88\xaf\xa7X݉|ֳ"
)

func TestParseJWTHeader(t *testing.T) {
	tests := []struct {
		name    string
		token   string
		want    int
		wantErr bool
	}{
		{
			"base64 error",
			"2",
			0,
			true,
		},
		{
			"Unmarshal error",
			"",
			0,
			true,
		},
		{
			"algoritm error",
			base64.RawURLEncoding.EncodeToString([]byte("{\"Alg\": \"foo\"}")),
			0,
			true,
		},
		{
			"ParseInt error",
			base64.RawURLEncoding.EncodeToString([]byte("{\"Alg\": \"EdDSA\", \"Kid\": \"x\"}")),
			0,
			true,
		},
		{
			"Valid header",
			base64.RawURLEncoding.EncodeToString([]byte("{\"Alg\": \"EdDSA\", \"Kid\": \"10\"}")),
			10,
			false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := ParseJWTHeader(tt.token)
			if (err != nil) != tt.wantErr {
				t.Errorf("ParseJWTHeader() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			var e *VerificationErr
			if tt.wantErr && !errors.As(err, &e) {
				t.Errorf("ParseJWTHeader() error = %T, wantErr %T", err, e)
			}
			if got != tt.want {
				t.Errorf("ParseJWTHeader() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestVerificator_get(t *testing.T) {
	key := []byte("foobar")
	keys := map[int32][]byte{10: key}

	tests := []struct {
		name    string
		keys    map[int32][]byte
		kid     int32
		wantKey []byte
		wantOk  bool
	}{
		{
			"Empty map",
			nil,
			33,
			nil,
			false,
		},
		{
			"Existing key",
			keys,
			10,
			key,
			true,
		},
		{
			"Non-existing key",
			keys,
			99,
			nil,
			false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			v := &Verificator{
				keys: tt.keys,
			}
			gotKey, gotOk := v.get(tt.kid)
			if !reflect.DeepEqual(gotKey, tt.wantKey) {
				t.Errorf("Verificator.get() gotKey = %v, want %v", gotKey, tt.wantKey)
			}
			if gotOk != tt.wantOk {
				t.Errorf("Verificator.get() gotOk = %v, want %v", gotOk, tt.wantOk)
			}
		})
	}
}

func TestVerificator_set(t *testing.T) {
	type args struct {
		kid int32
		key []byte
	}
	tests := []struct {
		name string
		keys map[int32][]byte
		args args
		want map[int32][]byte
	}{
		{
			"Nil map",
			nil,
			args{10, []byte("foobar")},
			map[int32][]byte{10: []byte("foobar")},
		},
		{
			"extra key",
			map[int32][]byte{10: []byte("foobar")},
			args{22, []byte("hello")},
			map[int32][]byte{10: []byte("foobar"), 22: []byte("hello")},
		},
		{
			"existing key",
			map[int32][]byte{10: []byte("foobar")},
			args{10, []byte("hello")},
			map[int32][]byte{10: []byte("hello")},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			v := &Verificator{
				keys: tt.keys,
			}
			v.set(tt.args.kid, tt.args.key)
			if !reflect.DeepEqual(v.keys, tt.want) {
				t.Errorf("Verificator.set() v.keys = %v, want %v", v.keys, tt.want)
			}
		})
	}
}

func TestVerificator_retrieve(t *testing.T) {
	ectx, cancel := context.WithTimeout(context.Background(), -1)
	defer cancel()

	type args struct {
		ctx context.Context
		kid int32
	}
	tests := []struct {
		name    string
		args    args
		want    []byte
		wantErr bool
	}{
		{
			"Expired context",
			args{ectx, 22},
			nil,
			true,
		},
		{
			"Valid key",
			args{context.Background(), 22},
			testKeyReponse,
			false,
		},
		{
			"Empty key response",
			args{context.Background(), 99},
			nil,
			true,
		},
		{
			"Empty request",
			args{ctx: context.Background()},
			nil,
			true,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			v := testVerificator
			got, err := v.retrieve(tt.args.ctx, tt.args.kid)
			if (err != nil) != tt.wantErr {
				t.Errorf("Verificator.retrieve() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("Verificator.retrieve() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestVerificator_getOrRetrieve(t *testing.T) {
	type args struct {
		ctx context.Context
		kid int32
	}
	tests := []struct {
		name    string
		args    args
		want    []byte
		wantErr bool
	}{
		{
			"Cached key",
			args{context.Background(), 10},
			[]byte(testPubKey),
			false,
		},
		{
			"Retrieve key",
			args{context.Background(), 22},
			testKeyReponse,
			false,
		},
		{
			"Empty request",
			args{ctx: context.Background()},
			nil,
			true,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			v := testVerificator
			got, err := v.getOrRetrieve(tt.args.ctx, tt.args.kid)
			if (err != nil) != tt.wantErr {
				t.Errorf("Verificator.getOrRetrieve() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("Verificator.getOrRetrieve() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestVerificator_Token(t *testing.T) {
	claims := &jwt.Claims{
		KeyID: "123",
		Registered: jwt.Registered{
			Expires:   jwt.NewNumericTime(time.Now().Add(time.Minute)),
			Audiences: []string{"tester"},
		},
	}
	unknownKid, err := claims.EdDSASign([]byte(testPrivKey))
	if err != nil {
		t.Fatal(err)
	}

	claims.KeyID = "10"

	valid, err := claims.EdDSASign([]byte(testPrivKey))
	if err != nil {
		t.Fatal(err)
	}

	a := bytes.Split(valid, []byte("."))
	u := bytes.Split(unknownKid, []byte("."))
	a[2] = u[2]
	altered := bytes.Join(a, []byte("."))

	exClaims := &jwt.Claims{
		KeyID: "10",
		Registered: jwt.Registered{
			Expires:   jwt.NewNumericTime(time.Now().Add(-1)),
			Audiences: []string{"tester"},
		},
	}
	expired, err := exClaims.EdDSASign([]byte(testPrivKey))
	if err != nil {
		t.Fatal(err)
	}

	waClaims := &jwt.Claims{
		KeyID: "10",
		Registered: jwt.Registered{
			Expires:   jwt.NewNumericTime(time.Now().Add(time.Minute)),
			Audiences: []string{"foobar"},
		},
	}
	wrongAudience, err := waClaims.EdDSASign([]byte(testPrivKey))
	if err != nil {
		t.Fatal(err)
	}

	type args struct {
		ctx   context.Context
		token string
	}
	tests := []struct {
		name    string
		args    args
		want    *jwt.Claims
		wantErr bool
	}{
		{
			"Invalid header",
			args{context.Background(), "/"},
			nil,
			true,
		},
		{
			"Unknown KID",
			args{context.Background(), string(unknownKid)},
			nil,
			true,
		},
		{
			"Altered token",
			args{context.Background(), string(altered)},
			nil,
			true,
		},
		{
			"Expired token",
			args{context.Background(), string(expired)},
			nil,
			true,
		},
		{
			"Valid token",
			args{context.Background(), string(valid)},
			claims,
			false,
		},
		{
			"Wrong audience",
			args{context.Background(), string(wrongAudience)},
			nil,
			true,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			v := testVerificator
			got, err := v.Token(tt.args.ctx, tt.args.token)
			if (err != nil) != tt.wantErr {
				t.Errorf("Verificator.Token() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if fmt.Sprint(got) != fmt.Sprint(tt.want) {
				t.Errorf("Verificator.Token() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestVerificationErr_Unwrap(t *testing.T) {
	tests := []struct {
		name string
		err  error
		want error
	}{
		{
			"Error",
			errors.New("Something"),
			errors.New("Something"),
		},
		{
			"Nil",
			nil,
			nil,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			e := &VerificationErr{
				err: tt.err,
			}
			got := e.Unwrap()
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("VerificationErr.Unwrap() error = %v, wantErr %v", got, tt.want)
			}
		})
	}
}

func TestVerificationErr_Error(t *testing.T) {
	type fields struct {
		name string
		err  error
	}
	tests := []struct {
		name   string
		fields fields
		want   string
	}{
		{
			"Some err",
			fields{
				name: "Something",
				err:  errors.New("embedded"),
			},
			"Something: embedded",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			e := &VerificationErr{
				name: tt.fields.name,
				err:  tt.fields.err,
			}
			if got := e.Error(); got != tt.want {
				t.Errorf("VerificationErr.Error() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestHasAnyEntry(t *testing.T) {
	type args struct {
		a []string
		b []string
	}
	tests := []struct {
		name string
		args args
		want bool
	}{
		{
			"Both nil",
			args{},
			true,
		},
		{
			"b nil",
			args{
				a: []string{"foo", "bar"},
			},
			false,
		},
		{
			"a nil",
			args{
				b: []string{"foo", "bar"},
			},
			false,
		},
		{
			"No match",
			args{
				a: []string{"hello", "world"},
				b: []string{"foo", "bar"},
			},
			false,
		},
		{
			"Match",
			args{
				a: []string{"hello", "world", "foo"},
				b: []string{"foo", "bar"},
			},
			true,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := HasAnyEntry(tt.args.a, tt.args.b); got != tt.want {
				t.Errorf("HasAnyEntry() = %v, want %v", got, tt.want)
			}
		})
	}
}
