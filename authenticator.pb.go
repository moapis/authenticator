// Copyright (c) 2019, Mohlmann Solutions SRL. All rights reserved.
// Use of this source code is governed by a License that can be found in the LICENSE file.
// SPDX-License-Identifier: BSD-3-Clause

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.22.0-devel
// 	protoc        v3.11.4
// source: authenticator.proto

package authenticator

import (
	context "context"
	proto "github.com/golang/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// This is a compile-time assertion that a sufficiently up-to-date version
// of the legacy proto package is being used.
const _ = proto.ProtoPackageIsVersion4

type UserData struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Email string `protobuf:"bytes,1,opt,name=email,proto3" json:"email,omitempty"`
	Name  string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (x *UserData) Reset() {
	*x = UserData{}
	if protoimpl.UnsafeEnabled {
		mi := &file_authenticator_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *UserData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UserData) ProtoMessage() {}

func (x *UserData) ProtoReflect() protoreflect.Message {
	mi := &file_authenticator_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UserData.ProtoReflect.Descriptor instead.
func (*UserData) Descriptor() ([]byte, []int) {
	return file_authenticator_proto_rawDescGZIP(), []int{0}
}

func (x *UserData) GetEmail() string {
	if x != nil {
		return x.Email
	}
	return ""
}

func (x *UserData) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

type StringSlice struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Slice []string `protobuf:"bytes,1,rep,name=slice,proto3" json:"slice,omitempty"`
}

func (x *StringSlice) Reset() {
	*x = StringSlice{}
	if protoimpl.UnsafeEnabled {
		mi := &file_authenticator_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *StringSlice) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StringSlice) ProtoMessage() {}

func (x *StringSlice) ProtoReflect() protoreflect.Message {
	mi := &file_authenticator_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StringSlice.ProtoReflect.Descriptor instead.
func (*StringSlice) Descriptor() ([]byte, []int) {
	return file_authenticator_proto_rawDescGZIP(), []int{1}
}

func (x *StringSlice) GetSlice() []string {
	if x != nil {
		return x.Slice
	}
	return nil
}

type CallBackUrl struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	BaseUrl string `protobuf:"bytes,1,opt,name=base_url,json=baseUrl,proto3" json:"base_url,omitempty"`
	// Query paramater key under which the token will be set in the callback URL.
	// If empty, it defaults to "token"
	TokenKey string `protobuf:"bytes,2,opt,name=token_key,json=tokenKey,proto3" json:"token_key,omitempty"`
	// Other query parameters which need to be added to the callback URL.
	Params map[string]*StringSlice `protobuf:"bytes,3,rep,name=params,proto3" json:"params,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (x *CallBackUrl) Reset() {
	*x = CallBackUrl{}
	if protoimpl.UnsafeEnabled {
		mi := &file_authenticator_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CallBackUrl) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CallBackUrl) ProtoMessage() {}

func (x *CallBackUrl) ProtoReflect() protoreflect.Message {
	mi := &file_authenticator_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CallBackUrl.ProtoReflect.Descriptor instead.
func (*CallBackUrl) Descriptor() ([]byte, []int) {
	return file_authenticator_proto_rawDescGZIP(), []int{2}
}

func (x *CallBackUrl) GetBaseUrl() string {
	if x != nil {
		return x.BaseUrl
	}
	return ""
}

func (x *CallBackUrl) GetTokenKey() string {
	if x != nil {
		return x.TokenKey
	}
	return ""
}

func (x *CallBackUrl) GetParams() map[string]*StringSlice {
	if x != nil {
		return x.Params
	}
	return nil
}

type RegistrationData struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Email string       `protobuf:"bytes,1,opt,name=email,proto3" json:"email,omitempty"`
	Name  string       `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Url   *CallBackUrl `protobuf:"bytes,3,opt,name=url,proto3" json:"url,omitempty"`
}

func (x *RegistrationData) Reset() {
	*x = RegistrationData{}
	if protoimpl.UnsafeEnabled {
		mi := &file_authenticator_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RegistrationData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RegistrationData) ProtoMessage() {}

func (x *RegistrationData) ProtoReflect() protoreflect.Message {
	mi := &file_authenticator_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RegistrationData.ProtoReflect.Descriptor instead.
func (*RegistrationData) Descriptor() ([]byte, []int) {
	return file_authenticator_proto_rawDescGZIP(), []int{3}
}

func (x *RegistrationData) GetEmail() string {
	if x != nil {
		return x.Email
	}
	return ""
}

func (x *RegistrationData) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *RegistrationData) GetUrl() *CallBackUrl {
	if x != nil {
		return x.Url
	}
	return nil
}

type RegistrationReply struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	UserId int32 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
}

func (x *RegistrationReply) Reset() {
	*x = RegistrationReply{}
	if protoimpl.UnsafeEnabled {
		mi := &file_authenticator_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RegistrationReply) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RegistrationReply) ProtoMessage() {}

func (x *RegistrationReply) ProtoReflect() protoreflect.Message {
	mi := &file_authenticator_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RegistrationReply.ProtoReflect.Descriptor instead.
func (*RegistrationReply) Descriptor() ([]byte, []int) {
	return file_authenticator_proto_rawDescGZIP(), []int{4}
}

func (x *RegistrationReply) GetUserId() int32 {
	if x != nil {
		return x.UserId
	}
	return 0
}

type AuthReply struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// JSON Web Token
	Jwt string `protobuf:"bytes,1,opt,name=jwt,proto3" json:"jwt,omitempty"`
}

func (x *AuthReply) Reset() {
	*x = AuthReply{}
	if protoimpl.UnsafeEnabled {
		mi := &file_authenticator_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AuthReply) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AuthReply) ProtoMessage() {}

func (x *AuthReply) ProtoReflect() protoreflect.Message {
	mi := &file_authenticator_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AuthReply.ProtoReflect.Descriptor instead.
func (*AuthReply) Descriptor() ([]byte, []int) {
	return file_authenticator_proto_rawDescGZIP(), []int{5}
}

func (x *AuthReply) GetJwt() string {
	if x != nil {
		return x.Jwt
	}
	return ""
}

// UserPassword holds the name or e-mail of the user and its password.
type UserPassword struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to User:
	//	*UserPassword_Email
	//	*UserPassword_Name
	User     isUserPassword_User `protobuf_oneof:"user"`
	Password string              `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
}

func (x *UserPassword) Reset() {
	*x = UserPassword{}
	if protoimpl.UnsafeEnabled {
		mi := &file_authenticator_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *UserPassword) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UserPassword) ProtoMessage() {}

func (x *UserPassword) ProtoReflect() protoreflect.Message {
	mi := &file_authenticator_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UserPassword.ProtoReflect.Descriptor instead.
func (*UserPassword) Descriptor() ([]byte, []int) {
	return file_authenticator_proto_rawDescGZIP(), []int{6}
}

func (m *UserPassword) GetUser() isUserPassword_User {
	if m != nil {
		return m.User
	}
	return nil
}

func (x *UserPassword) GetEmail() string {
	if x, ok := x.GetUser().(*UserPassword_Email); ok {
		return x.Email
	}
	return ""
}

func (x *UserPassword) GetName() string {
	if x, ok := x.GetUser().(*UserPassword_Name); ok {
		return x.Name
	}
	return ""
}

func (x *UserPassword) GetPassword() string {
	if x != nil {
		return x.Password
	}
	return ""
}

type isUserPassword_User interface {
	isUserPassword_User()
}

type UserPassword_Email struct {
	Email string `protobuf:"bytes,1,opt,name=email,proto3,oneof"`
}

type UserPassword_Name struct {
	Name string `protobuf:"bytes,2,opt,name=name,proto3,oneof"`
}

func (*UserPassword_Email) isUserPassword_User() {}

func (*UserPassword_Name) isUserPassword_User() {}

type NewUserPassword struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to User:
	//	*NewUserPassword_Email
	//	*NewUserPassword_Name
	User isNewUserPassword_User `protobuf_oneof:"user"`
	// Types that are assignable to Credential:
	//	*NewUserPassword_OldPassword
	//	*NewUserPassword_ResetToken
	Credential  isNewUserPassword_Credential `protobuf_oneof:"credential"`
	NewPassword string                       `protobuf:"bytes,5,opt,name=new_password,json=newPassword,proto3" json:"new_password,omitempty"`
}

func (x *NewUserPassword) Reset() {
	*x = NewUserPassword{}
	if protoimpl.UnsafeEnabled {
		mi := &file_authenticator_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *NewUserPassword) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NewUserPassword) ProtoMessage() {}

func (x *NewUserPassword) ProtoReflect() protoreflect.Message {
	mi := &file_authenticator_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NewUserPassword.ProtoReflect.Descriptor instead.
func (*NewUserPassword) Descriptor() ([]byte, []int) {
	return file_authenticator_proto_rawDescGZIP(), []int{7}
}

func (m *NewUserPassword) GetUser() isNewUserPassword_User {
	if m != nil {
		return m.User
	}
	return nil
}

func (x *NewUserPassword) GetEmail() string {
	if x, ok := x.GetUser().(*NewUserPassword_Email); ok {
		return x.Email
	}
	return ""
}

func (x *NewUserPassword) GetName() string {
	if x, ok := x.GetUser().(*NewUserPassword_Name); ok {
		return x.Name
	}
	return ""
}

func (m *NewUserPassword) GetCredential() isNewUserPassword_Credential {
	if m != nil {
		return m.Credential
	}
	return nil
}

func (x *NewUserPassword) GetOldPassword() string {
	if x, ok := x.GetCredential().(*NewUserPassword_OldPassword); ok {
		return x.OldPassword
	}
	return ""
}

func (x *NewUserPassword) GetResetToken() string {
	if x, ok := x.GetCredential().(*NewUserPassword_ResetToken); ok {
		return x.ResetToken
	}
	return ""
}

func (x *NewUserPassword) GetNewPassword() string {
	if x != nil {
		return x.NewPassword
	}
	return ""
}

type isNewUserPassword_User interface {
	isNewUserPassword_User()
}

type NewUserPassword_Email struct {
	Email string `protobuf:"bytes,1,opt,name=email,proto3,oneof"`
}

type NewUserPassword_Name struct {
	Name string `protobuf:"bytes,2,opt,name=name,proto3,oneof"`
}

func (*NewUserPassword_Email) isNewUserPassword_User() {}

func (*NewUserPassword_Name) isNewUserPassword_User() {}

type isNewUserPassword_Credential interface {
	isNewUserPassword_Credential()
}

type NewUserPassword_OldPassword struct {
	OldPassword string `protobuf:"bytes,3,opt,name=old_password,json=oldPassword,proto3,oneof"`
}

type NewUserPassword_ResetToken struct {
	ResetToken string `protobuf:"bytes,4,opt,name=reset_token,json=resetToken,proto3,oneof"`
}

func (*NewUserPassword_OldPassword) isNewUserPassword_Credential() {}

func (*NewUserPassword_ResetToken) isNewUserPassword_Credential() {}

type ChangePwReply struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
}

func (x *ChangePwReply) Reset() {
	*x = ChangePwReply{}
	if protoimpl.UnsafeEnabled {
		mi := &file_authenticator_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ChangePwReply) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChangePwReply) ProtoMessage() {}

func (x *ChangePwReply) ProtoReflect() protoreflect.Message {
	mi := &file_authenticator_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChangePwReply.ProtoReflect.Descriptor instead.
func (*ChangePwReply) Descriptor() ([]byte, []int) {
	return file_authenticator_proto_rawDescGZIP(), []int{8}
}

func (x *ChangePwReply) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

type Exists struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Email bool `protobuf:"varint,1,opt,name=email,proto3" json:"email,omitempty"`
	Name  bool `protobuf:"varint,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (x *Exists) Reset() {
	*x = Exists{}
	if protoimpl.UnsafeEnabled {
		mi := &file_authenticator_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Exists) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Exists) ProtoMessage() {}

func (x *Exists) ProtoReflect() protoreflect.Message {
	mi := &file_authenticator_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Exists.ProtoReflect.Descriptor instead.
func (*Exists) Descriptor() ([]byte, []int) {
	return file_authenticator_proto_rawDescGZIP(), []int{9}
}

func (x *Exists) GetEmail() bool {
	if x != nil {
		return x.Email
	}
	return false
}

func (x *Exists) GetName() bool {
	if x != nil {
		return x.Name
	}
	return false
}

type PublicUser struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Uuid string `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
}

func (x *PublicUser) Reset() {
	*x = PublicUser{}
	if protoimpl.UnsafeEnabled {
		mi := &file_authenticator_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PublicUser) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PublicUser) ProtoMessage() {}

func (x *PublicUser) ProtoReflect() protoreflect.Message {
	mi := &file_authenticator_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PublicUser.ProtoReflect.Descriptor instead.
func (*PublicUser) Descriptor() ([]byte, []int) {
	return file_authenticator_proto_rawDescGZIP(), []int{10}
}

func (x *PublicUser) GetUuid() string {
	if x != nil {
		return x.Uuid
	}
	return ""
}

type KeyID struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Kid int32 `protobuf:"varint,1,opt,name=kid,proto3" json:"kid,omitempty"`
}

func (x *KeyID) Reset() {
	*x = KeyID{}
	if protoimpl.UnsafeEnabled {
		mi := &file_authenticator_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *KeyID) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KeyID) ProtoMessage() {}

func (x *KeyID) ProtoReflect() protoreflect.Message {
	mi := &file_authenticator_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KeyID.ProtoReflect.Descriptor instead.
func (*KeyID) Descriptor() ([]byte, []int) {
	return file_authenticator_proto_rawDescGZIP(), []int{11}
}

func (x *KeyID) GetKid() int32 {
	if x != nil {
		return x.Kid
	}
	return 0
}

type PublicKey struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Key []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
}

func (x *PublicKey) Reset() {
	*x = PublicKey{}
	if protoimpl.UnsafeEnabled {
		mi := &file_authenticator_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PublicKey) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PublicKey) ProtoMessage() {}

func (x *PublicKey) ProtoReflect() protoreflect.Message {
	mi := &file_authenticator_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PublicKey.ProtoReflect.Descriptor instead.
func (*PublicKey) Descriptor() ([]byte, []int) {
	return file_authenticator_proto_rawDescGZIP(), []int{12}
}

func (x *PublicKey) GetKey() []byte {
	if x != nil {
		return x.Key
	}
	return nil
}

type UserEmail struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Email string       `protobuf:"bytes,1,opt,name=email,proto3" json:"email,omitempty"`
	Url   *CallBackUrl `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
}

func (x *UserEmail) Reset() {
	*x = UserEmail{}
	if protoimpl.UnsafeEnabled {
		mi := &file_authenticator_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *UserEmail) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UserEmail) ProtoMessage() {}

func (x *UserEmail) ProtoReflect() protoreflect.Message {
	mi := &file_authenticator_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UserEmail.ProtoReflect.Descriptor instead.
func (*UserEmail) Descriptor() ([]byte, []int) {
	return file_authenticator_proto_rawDescGZIP(), []int{13}
}

func (x *UserEmail) GetEmail() string {
	if x != nil {
		return x.Email
	}
	return ""
}

func (x *UserEmail) GetUrl() *CallBackUrl {
	if x != nil {
		return x.Url
	}
	return nil
}

var File_authenticator_proto protoreflect.FileDescriptor

var file_authenticator_proto_rawDesc = []byte{
	0x0a, 0x13, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74, 0x69, 0x63, 0x61, 0x74, 0x6f, 0x72, 0x2e,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0d, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74, 0x69, 0x63,
	0x61, 0x74, 0x6f, 0x72, 0x1a, 0x1b, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x65, 0x6d, 0x70, 0x74, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x22, 0x34, 0x0a, 0x08, 0x55, 0x73, 0x65, 0x72, 0x44, 0x61, 0x74, 0x61, 0x12, 0x14, 0x0a,
	0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x65, 0x6d,
	0x61, 0x69, 0x6c, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x22, 0x23, 0x0a, 0x0b, 0x53, 0x74, 0x72, 0x69, 0x6e,
	0x67, 0x53, 0x6c, 0x69, 0x63, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x73, 0x6c, 0x69, 0x63, 0x65, 0x18,
	0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x05, 0x73, 0x6c, 0x69, 0x63, 0x65, 0x22, 0xdc, 0x01, 0x0a,
	0x0b, 0x43, 0x61, 0x6c, 0x6c, 0x42, 0x61, 0x63, 0x6b, 0x55, 0x72, 0x6c, 0x12, 0x19, 0x0a, 0x08,
	0x62, 0x61, 0x73, 0x65, 0x5f, 0x75, 0x72, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07,
	0x62, 0x61, 0x73, 0x65, 0x55, 0x72, 0x6c, 0x12, 0x1b, 0x0a, 0x09, 0x74, 0x6f, 0x6b, 0x65, 0x6e,
	0x5f, 0x6b, 0x65, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x74, 0x6f, 0x6b, 0x65,
	0x6e, 0x4b, 0x65, 0x79, 0x12, 0x3e, 0x0a, 0x06, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x73, 0x18, 0x03,
	0x20, 0x03, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74, 0x69, 0x63,
	0x61, 0x74, 0x6f, 0x72, 0x2e, 0x43, 0x61, 0x6c, 0x6c, 0x42, 0x61, 0x63, 0x6b, 0x55, 0x72, 0x6c,
	0x2e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x06, 0x70, 0x61,
	0x72, 0x61, 0x6d, 0x73, 0x1a, 0x55, 0x0a, 0x0b, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x73, 0x45, 0x6e,
	0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x30, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74, 0x69, 0x63,
	0x61, 0x74, 0x6f, 0x72, 0x2e, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x53, 0x6c, 0x69, 0x63, 0x65,
	0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0x6a, 0x0a, 0x10, 0x52,
	0x65, 0x67, 0x69, 0x73, 0x74, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x44, 0x61, 0x74, 0x61, 0x12,
	0x14, 0x0a, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05,
	0x65, 0x6d, 0x61, 0x69, 0x6c, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x2c, 0x0a, 0x03, 0x75, 0x72, 0x6c,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74,
	0x69, 0x63, 0x61, 0x74, 0x6f, 0x72, 0x2e, 0x43, 0x61, 0x6c, 0x6c, 0x42, 0x61, 0x63, 0x6b, 0x55,
	0x72, 0x6c, 0x52, 0x03, 0x75, 0x72, 0x6c, 0x22, 0x2c, 0x0a, 0x11, 0x52, 0x65, 0x67, 0x69, 0x73,
	0x74, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x70, 0x6c, 0x79, 0x12, 0x17, 0x0a, 0x07,
	0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x06, 0x75,
	0x73, 0x65, 0x72, 0x49, 0x64, 0x22, 0x1d, 0x0a, 0x09, 0x41, 0x75, 0x74, 0x68, 0x52, 0x65, 0x70,
	0x6c, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6a, 0x77, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x03, 0x6a, 0x77, 0x74, 0x22, 0x60, 0x0a, 0x0c, 0x55, 0x73, 0x65, 0x72, 0x50, 0x61, 0x73, 0x73,
	0x77, 0x6f, 0x72, 0x64, 0x12, 0x16, 0x0a, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x09, 0x48, 0x00, 0x52, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x12, 0x14, 0x0a, 0x04,
	0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x48, 0x00, 0x52, 0x04, 0x6e, 0x61,
	0x6d, 0x65, 0x12, 0x1a, 0x0a, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x42, 0x06,
	0x0a, 0x04, 0x75, 0x73, 0x65, 0x72, 0x22, 0xc0, 0x01, 0x0a, 0x0f, 0x4e, 0x65, 0x77, 0x55, 0x73,
	0x65, 0x72, 0x50, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x12, 0x16, 0x0a, 0x05, 0x65, 0x6d,
	0x61, 0x69, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x48, 0x00, 0x52, 0x05, 0x65, 0x6d, 0x61,
	0x69, 0x6c, 0x12, 0x14, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
	0x48, 0x00, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x23, 0x0a, 0x0c, 0x6f, 0x6c, 0x64, 0x5f,
	0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x48, 0x01,
	0x52, 0x0b, 0x6f, 0x6c, 0x64, 0x50, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x12, 0x21, 0x0a,
	0x0b, 0x72, 0x65, 0x73, 0x65, 0x74, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x04, 0x20, 0x01,
	0x28, 0x09, 0x48, 0x01, 0x52, 0x0a, 0x72, 0x65, 0x73, 0x65, 0x74, 0x54, 0x6f, 0x6b, 0x65, 0x6e,
	0x12, 0x21, 0x0a, 0x0c, 0x6e, 0x65, 0x77, 0x5f, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64,
	0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x6e, 0x65, 0x77, 0x50, 0x61, 0x73, 0x73, 0x77,
	0x6f, 0x72, 0x64, 0x42, 0x06, 0x0a, 0x04, 0x75, 0x73, 0x65, 0x72, 0x42, 0x0c, 0x0a, 0x0a, 0x63,
	0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x22, 0x29, 0x0a, 0x0d, 0x43, 0x68, 0x61,
	0x6e, 0x67, 0x65, 0x50, 0x77, 0x52, 0x65, 0x70, 0x6c, 0x79, 0x12, 0x18, 0x0a, 0x07, 0x73, 0x75,
	0x63, 0x63, 0x65, 0x73, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x73, 0x75, 0x63,
	0x63, 0x65, 0x73, 0x73, 0x22, 0x32, 0x0a, 0x06, 0x45, 0x78, 0x69, 0x73, 0x74, 0x73, 0x12, 0x14,
	0x0a, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x05, 0x65,
	0x6d, 0x61, 0x69, 0x6c, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x08, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x22, 0x20, 0x0a, 0x0a, 0x50, 0x75, 0x62, 0x6c,
	0x69, 0x63, 0x55, 0x73, 0x65, 0x72, 0x12, 0x12, 0x0a, 0x04, 0x75, 0x75, 0x69, 0x64, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x75, 0x75, 0x69, 0x64, 0x22, 0x19, 0x0a, 0x05, 0x4b, 0x65,
	0x79, 0x49, 0x44, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05,
	0x52, 0x03, 0x6b, 0x69, 0x64, 0x22, 0x1d, 0x0a, 0x09, 0x50, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x4b,
	0x65, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x52,
	0x03, 0x6b, 0x65, 0x79, 0x22, 0x4f, 0x0a, 0x09, 0x55, 0x73, 0x65, 0x72, 0x45, 0x6d, 0x61, 0x69,
	0x6c, 0x12, 0x14, 0x0a, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x12, 0x2c, 0x0a, 0x03, 0x75, 0x72, 0x6c, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74, 0x69, 0x63,
	0x61, 0x74, 0x6f, 0x72, 0x2e, 0x43, 0x61, 0x6c, 0x6c, 0x42, 0x61, 0x63, 0x6b, 0x55, 0x72, 0x6c,
	0x52, 0x03, 0x75, 0x72, 0x6c, 0x32, 0xa0, 0x05, 0x0a, 0x0d, 0x41, 0x75, 0x74, 0x68, 0x65, 0x6e,
	0x74, 0x69, 0x63, 0x61, 0x74, 0x6f, 0x72, 0x12, 0x55, 0x0a, 0x0e, 0x52, 0x65, 0x67, 0x69, 0x73,
	0x74, 0x65, 0x72, 0x50, 0x77, 0x55, 0x73, 0x65, 0x72, 0x12, 0x1f, 0x2e, 0x61, 0x75, 0x74, 0x68,
	0x65, 0x6e, 0x74, 0x69, 0x63, 0x61, 0x74, 0x6f, 0x72, 0x2e, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74,
	0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x44, 0x61, 0x74, 0x61, 0x1a, 0x20, 0x2e, 0x61, 0x75, 0x74,
	0x68, 0x65, 0x6e, 0x74, 0x69, 0x63, 0x61, 0x74, 0x6f, 0x72, 0x2e, 0x52, 0x65, 0x67, 0x69, 0x73,
	0x74, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x70, 0x6c, 0x79, 0x22, 0x00, 0x12, 0x4d,
	0x0a, 0x12, 0x41, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74, 0x69, 0x63, 0x61, 0x74, 0x65, 0x50, 0x77,
	0x55, 0x73, 0x65, 0x72, 0x12, 0x1b, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74, 0x69, 0x63,
	0x61, 0x74, 0x6f, 0x72, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x50, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72,
	0x64, 0x1a, 0x18, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74, 0x69, 0x63, 0x61, 0x74, 0x6f,
	0x72, 0x2e, 0x41, 0x75, 0x74, 0x68, 0x52, 0x65, 0x70, 0x6c, 0x79, 0x22, 0x00, 0x12, 0x4e, 0x0a,
	0x0c, 0x43, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x55, 0x73, 0x65, 0x72, 0x50, 0x77, 0x12, 0x1e, 0x2e,
	0x61, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74, 0x69, 0x63, 0x61, 0x74, 0x6f, 0x72, 0x2e, 0x4e, 0x65,
	0x77, 0x55, 0x73, 0x65, 0x72, 0x50, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x1a, 0x1c, 0x2e,
	0x61, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74, 0x69, 0x63, 0x61, 0x74, 0x6f, 0x72, 0x2e, 0x43, 0x68,
	0x61, 0x6e, 0x67, 0x65, 0x50, 0x77, 0x52, 0x65, 0x70, 0x6c, 0x79, 0x22, 0x00, 0x12, 0x43, 0x0a,
	0x0f, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x55, 0x73, 0x65, 0x72, 0x45, 0x78, 0x69, 0x73, 0x74, 0x73,
	0x12, 0x17, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74, 0x69, 0x63, 0x61, 0x74, 0x6f, 0x72,
	0x2e, 0x55, 0x73, 0x65, 0x72, 0x44, 0x61, 0x74, 0x61, 0x1a, 0x15, 0x2e, 0x61, 0x75, 0x74, 0x68,
	0x65, 0x6e, 0x74, 0x69, 0x63, 0x61, 0x74, 0x6f, 0x72, 0x2e, 0x45, 0x78, 0x69, 0x73, 0x74, 0x73,
	0x22, 0x00, 0x12, 0x42, 0x0a, 0x0a, 0x56, 0x65, 0x72, 0x69, 0x66, 0x79, 0x55, 0x73, 0x65, 0x72,
	0x12, 0x18, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74, 0x69, 0x63, 0x61, 0x74, 0x6f, 0x72,
	0x2e, 0x41, 0x75, 0x74, 0x68, 0x52, 0x65, 0x70, 0x6c, 0x79, 0x1a, 0x18, 0x2e, 0x61, 0x75, 0x74,
	0x68, 0x65, 0x6e, 0x74, 0x69, 0x63, 0x61, 0x74, 0x6f, 0x72, 0x2e, 0x41, 0x75, 0x74, 0x68, 0x52,
	0x65, 0x70, 0x6c, 0x79, 0x22, 0x00, 0x12, 0x44, 0x0a, 0x0c, 0x52, 0x65, 0x66, 0x72, 0x65, 0x73,
	0x68, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x12, 0x18, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74,
	0x69, 0x63, 0x61, 0x74, 0x6f, 0x72, 0x2e, 0x41, 0x75, 0x74, 0x68, 0x52, 0x65, 0x70, 0x6c, 0x79,
	0x1a, 0x18, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74, 0x69, 0x63, 0x61, 0x74, 0x6f, 0x72,
	0x2e, 0x41, 0x75, 0x74, 0x68, 0x52, 0x65, 0x70, 0x6c, 0x79, 0x22, 0x00, 0x12, 0x48, 0x0a, 0x0f,
	0x50, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x55, 0x73, 0x65, 0x72, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x12,
	0x19, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74, 0x69, 0x63, 0x61, 0x74, 0x6f, 0x72, 0x2e,
	0x50, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x55, 0x73, 0x65, 0x72, 0x1a, 0x18, 0x2e, 0x61, 0x75, 0x74,
	0x68, 0x65, 0x6e, 0x74, 0x69, 0x63, 0x61, 0x74, 0x6f, 0x72, 0x2e, 0x41, 0x75, 0x74, 0x68, 0x52,
	0x65, 0x70, 0x6c, 0x79, 0x22, 0x00, 0x12, 0x3d, 0x0a, 0x09, 0x47, 0x65, 0x74, 0x50, 0x75, 0x62,
	0x4b, 0x65, 0x79, 0x12, 0x14, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74, 0x69, 0x63, 0x61,
	0x74, 0x6f, 0x72, 0x2e, 0x4b, 0x65, 0x79, 0x49, 0x44, 0x1a, 0x18, 0x2e, 0x61, 0x75, 0x74, 0x68,
	0x65, 0x6e, 0x74, 0x69, 0x63, 0x61, 0x74, 0x6f, 0x72, 0x2e, 0x50, 0x75, 0x62, 0x6c, 0x69, 0x63,
	0x4b, 0x65, 0x79, 0x22, 0x00, 0x12, 0x41, 0x0a, 0x0b, 0x52, 0x65, 0x73, 0x65, 0x74, 0x55, 0x73,
	0x65, 0x72, 0x50, 0x57, 0x12, 0x18, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74, 0x69, 0x63,
	0x61, 0x74, 0x6f, 0x72, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x45, 0x6d, 0x61, 0x69, 0x6c, 0x1a, 0x16,
	0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66,
	0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x22, 0x00, 0x42, 0x21, 0x5a, 0x1f, 0x67, 0x69, 0x74, 0x68,
	0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x6d, 0x6f, 0x61, 0x70, 0x69, 0x73, 0x2f, 0x61, 0x75,
	0x74, 0x68, 0x65, 0x6e, 0x74, 0x69, 0x63, 0x61, 0x74, 0x6f, 0x72, 0x62, 0x06, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x33,
}

var (
	file_authenticator_proto_rawDescOnce sync.Once
	file_authenticator_proto_rawDescData = file_authenticator_proto_rawDesc
)

func file_authenticator_proto_rawDescGZIP() []byte {
	file_authenticator_proto_rawDescOnce.Do(func() {
		file_authenticator_proto_rawDescData = protoimpl.X.CompressGZIP(file_authenticator_proto_rawDescData)
	})
	return file_authenticator_proto_rawDescData
}

var file_authenticator_proto_msgTypes = make([]protoimpl.MessageInfo, 15)
var file_authenticator_proto_goTypes = []interface{}{
	(*UserData)(nil),          // 0: authenticator.UserData
	(*StringSlice)(nil),       // 1: authenticator.StringSlice
	(*CallBackUrl)(nil),       // 2: authenticator.CallBackUrl
	(*RegistrationData)(nil),  // 3: authenticator.RegistrationData
	(*RegistrationReply)(nil), // 4: authenticator.RegistrationReply
	(*AuthReply)(nil),         // 5: authenticator.AuthReply
	(*UserPassword)(nil),      // 6: authenticator.UserPassword
	(*NewUserPassword)(nil),   // 7: authenticator.NewUserPassword
	(*ChangePwReply)(nil),     // 8: authenticator.ChangePwReply
	(*Exists)(nil),            // 9: authenticator.Exists
	(*PublicUser)(nil),        // 10: authenticator.PublicUser
	(*KeyID)(nil),             // 11: authenticator.KeyID
	(*PublicKey)(nil),         // 12: authenticator.PublicKey
	(*UserEmail)(nil),         // 13: authenticator.UserEmail
	nil,                       // 14: authenticator.CallBackUrl.ParamsEntry
	(*empty.Empty)(nil),       // 15: google.protobuf.Empty
}
var file_authenticator_proto_depIdxs = []int32{
	14, // 0: authenticator.CallBackUrl.params:type_name -> authenticator.CallBackUrl.ParamsEntry
	2,  // 1: authenticator.RegistrationData.url:type_name -> authenticator.CallBackUrl
	2,  // 2: authenticator.UserEmail.url:type_name -> authenticator.CallBackUrl
	1,  // 3: authenticator.CallBackUrl.ParamsEntry.value:type_name -> authenticator.StringSlice
	3,  // 4: authenticator.Authenticator.RegisterPwUser:input_type -> authenticator.RegistrationData
	6,  // 5: authenticator.Authenticator.AuthenticatePwUser:input_type -> authenticator.UserPassword
	7,  // 6: authenticator.Authenticator.ChangeUserPw:input_type -> authenticator.NewUserPassword
	0,  // 7: authenticator.Authenticator.CheckUserExists:input_type -> authenticator.UserData
	5,  // 8: authenticator.Authenticator.VerifyUser:input_type -> authenticator.AuthReply
	5,  // 9: authenticator.Authenticator.RefreshToken:input_type -> authenticator.AuthReply
	10, // 10: authenticator.Authenticator.PublicUserToken:input_type -> authenticator.PublicUser
	11, // 11: authenticator.Authenticator.GetPubKey:input_type -> authenticator.KeyID
	13, // 12: authenticator.Authenticator.ResetUserPW:input_type -> authenticator.UserEmail
	4,  // 13: authenticator.Authenticator.RegisterPwUser:output_type -> authenticator.RegistrationReply
	5,  // 14: authenticator.Authenticator.AuthenticatePwUser:output_type -> authenticator.AuthReply
	8,  // 15: authenticator.Authenticator.ChangeUserPw:output_type -> authenticator.ChangePwReply
	9,  // 16: authenticator.Authenticator.CheckUserExists:output_type -> authenticator.Exists
	5,  // 17: authenticator.Authenticator.VerifyUser:output_type -> authenticator.AuthReply
	5,  // 18: authenticator.Authenticator.RefreshToken:output_type -> authenticator.AuthReply
	5,  // 19: authenticator.Authenticator.PublicUserToken:output_type -> authenticator.AuthReply
	12, // 20: authenticator.Authenticator.GetPubKey:output_type -> authenticator.PublicKey
	15, // 21: authenticator.Authenticator.ResetUserPW:output_type -> google.protobuf.Empty
	13, // [13:22] is the sub-list for method output_type
	4,  // [4:13] is the sub-list for method input_type
	4,  // [4:4] is the sub-list for extension type_name
	4,  // [4:4] is the sub-list for extension extendee
	0,  // [0:4] is the sub-list for field type_name
}

func init() { file_authenticator_proto_init() }
func file_authenticator_proto_init() {
	if File_authenticator_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_authenticator_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*UserData); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_authenticator_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*StringSlice); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_authenticator_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CallBackUrl); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_authenticator_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RegistrationData); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_authenticator_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RegistrationReply); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_authenticator_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AuthReply); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_authenticator_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*UserPassword); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_authenticator_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*NewUserPassword); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_authenticator_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ChangePwReply); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_authenticator_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Exists); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_authenticator_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PublicUser); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_authenticator_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*KeyID); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_authenticator_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PublicKey); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_authenticator_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*UserEmail); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	file_authenticator_proto_msgTypes[6].OneofWrappers = []interface{}{
		(*UserPassword_Email)(nil),
		(*UserPassword_Name)(nil),
	}
	file_authenticator_proto_msgTypes[7].OneofWrappers = []interface{}{
		(*NewUserPassword_Email)(nil),
		(*NewUserPassword_Name)(nil),
		(*NewUserPassword_OldPassword)(nil),
		(*NewUserPassword_ResetToken)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_authenticator_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   15,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_authenticator_proto_goTypes,
		DependencyIndexes: file_authenticator_proto_depIdxs,
		MessageInfos:      file_authenticator_proto_msgTypes,
	}.Build()
	File_authenticator_proto = out.File
	file_authenticator_proto_rawDesc = nil
	file_authenticator_proto_goTypes = nil
	file_authenticator_proto_depIdxs = nil
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// AuthenticatorClient is the client API for Authenticator service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AuthenticatorClient interface {
	// RegisterPwUser registers a new user which can authenticate using a PW.
	// Server implementation should grant the user only a public role untill verification is complete.
	// Authorization: Public
	RegisterPwUser(ctx context.Context, in *RegistrationData, opts ...grpc.CallOption) (*RegistrationReply, error)
	// PasswordAuth authenticates the user by its registered email or username and password.
	// Authorization: Public
	AuthenticatePwUser(ctx context.Context, in *UserPassword, opts ...grpc.CallOption) (*AuthReply, error)
	// ChangeUserPw changes the password for the user. It needs either the old password or a password reset token.
	// Authorization: Public
	ChangeUserPw(ctx context.Context, in *NewUserPassword, opts ...grpc.CallOption) (*ChangePwReply, error)
	// CheckUserExists returns true for the UserID fields which already exists.
	// Authorization: Basic
	CheckUserExists(ctx context.Context, in *UserData, opts ...grpc.CallOption) (*Exists, error)
	// VerifyUser by previously transmitted (email) verification token
	// Authorization: Public
	VerifyUser(ctx context.Context, in *AuthReply, opts ...grpc.CallOption) (*AuthReply, error)
	// RefreshToken using an old (and valid!) token.
	// The user id and its authorization level are verified against the database.
	// Authorization: Public
	RefreshToken(ctx context.Context, in *AuthReply, opts ...grpc.CallOption) (*AuthReply, error)
	// PublicUserToken generates a token for public and unauthenticated users.
	// Such token can be used for API access and session tracking.
	// Authorization: Internal
	PublicUserToken(ctx context.Context, in *PublicUser, opts ...grpc.CallOption) (*AuthReply, error)
	// GetPubKey retrieves registered public keys from the database, identified by KeyIDs.
	// Authorization: Internal
	GetPubKey(ctx context.Context, in *KeyID, opts ...grpc.CallOption) (*PublicKey, error)
	// ResetUserPW sends a password reset e-mail to a registered user.
	// The e-mail will contain an URL, as per passed CallBackURL.
	// The URL will contain a token which (only) can be used for setting a new password.
	ResetUserPW(ctx context.Context, in *UserEmail, opts ...grpc.CallOption) (*empty.Empty, error)
}

type authenticatorClient struct {
	cc grpc.ClientConnInterface
}

func NewAuthenticatorClient(cc grpc.ClientConnInterface) AuthenticatorClient {
	return &authenticatorClient{cc}
}

func (c *authenticatorClient) RegisterPwUser(ctx context.Context, in *RegistrationData, opts ...grpc.CallOption) (*RegistrationReply, error) {
	out := new(RegistrationReply)
	err := c.cc.Invoke(ctx, "/authenticator.Authenticator/RegisterPwUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authenticatorClient) AuthenticatePwUser(ctx context.Context, in *UserPassword, opts ...grpc.CallOption) (*AuthReply, error) {
	out := new(AuthReply)
	err := c.cc.Invoke(ctx, "/authenticator.Authenticator/AuthenticatePwUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authenticatorClient) ChangeUserPw(ctx context.Context, in *NewUserPassword, opts ...grpc.CallOption) (*ChangePwReply, error) {
	out := new(ChangePwReply)
	err := c.cc.Invoke(ctx, "/authenticator.Authenticator/ChangeUserPw", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authenticatorClient) CheckUserExists(ctx context.Context, in *UserData, opts ...grpc.CallOption) (*Exists, error) {
	out := new(Exists)
	err := c.cc.Invoke(ctx, "/authenticator.Authenticator/CheckUserExists", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authenticatorClient) VerifyUser(ctx context.Context, in *AuthReply, opts ...grpc.CallOption) (*AuthReply, error) {
	out := new(AuthReply)
	err := c.cc.Invoke(ctx, "/authenticator.Authenticator/VerifyUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authenticatorClient) RefreshToken(ctx context.Context, in *AuthReply, opts ...grpc.CallOption) (*AuthReply, error) {
	out := new(AuthReply)
	err := c.cc.Invoke(ctx, "/authenticator.Authenticator/RefreshToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authenticatorClient) PublicUserToken(ctx context.Context, in *PublicUser, opts ...grpc.CallOption) (*AuthReply, error) {
	out := new(AuthReply)
	err := c.cc.Invoke(ctx, "/authenticator.Authenticator/PublicUserToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authenticatorClient) GetPubKey(ctx context.Context, in *KeyID, opts ...grpc.CallOption) (*PublicKey, error) {
	out := new(PublicKey)
	err := c.cc.Invoke(ctx, "/authenticator.Authenticator/GetPubKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authenticatorClient) ResetUserPW(ctx context.Context, in *UserEmail, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/authenticator.Authenticator/ResetUserPW", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AuthenticatorServer is the server API for Authenticator service.
type AuthenticatorServer interface {
	// RegisterPwUser registers a new user which can authenticate using a PW.
	// Server implementation should grant the user only a public role untill verification is complete.
	// Authorization: Public
	RegisterPwUser(context.Context, *RegistrationData) (*RegistrationReply, error)
	// PasswordAuth authenticates the user by its registered email or username and password.
	// Authorization: Public
	AuthenticatePwUser(context.Context, *UserPassword) (*AuthReply, error)
	// ChangeUserPw changes the password for the user. It needs either the old password or a password reset token.
	// Authorization: Public
	ChangeUserPw(context.Context, *NewUserPassword) (*ChangePwReply, error)
	// CheckUserExists returns true for the UserID fields which already exists.
	// Authorization: Basic
	CheckUserExists(context.Context, *UserData) (*Exists, error)
	// VerifyUser by previously transmitted (email) verification token
	// Authorization: Public
	VerifyUser(context.Context, *AuthReply) (*AuthReply, error)
	// RefreshToken using an old (and valid!) token.
	// The user id and its authorization level are verified against the database.
	// Authorization: Public
	RefreshToken(context.Context, *AuthReply) (*AuthReply, error)
	// PublicUserToken generates a token for public and unauthenticated users.
	// Such token can be used for API access and session tracking.
	// Authorization: Internal
	PublicUserToken(context.Context, *PublicUser) (*AuthReply, error)
	// GetPubKey retrieves registered public keys from the database, identified by KeyIDs.
	// Authorization: Internal
	GetPubKey(context.Context, *KeyID) (*PublicKey, error)
	// ResetUserPW sends a password reset e-mail to a registered user.
	// The e-mail will contain an URL, as per passed CallBackURL.
	// The URL will contain a token which (only) can be used for setting a new password.
	ResetUserPW(context.Context, *UserEmail) (*empty.Empty, error)
}

// UnimplementedAuthenticatorServer can be embedded to have forward compatible implementations.
type UnimplementedAuthenticatorServer struct {
}

func (*UnimplementedAuthenticatorServer) RegisterPwUser(context.Context, *RegistrationData) (*RegistrationReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterPwUser not implemented")
}
func (*UnimplementedAuthenticatorServer) AuthenticatePwUser(context.Context, *UserPassword) (*AuthReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthenticatePwUser not implemented")
}
func (*UnimplementedAuthenticatorServer) ChangeUserPw(context.Context, *NewUserPassword) (*ChangePwReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangeUserPw not implemented")
}
func (*UnimplementedAuthenticatorServer) CheckUserExists(context.Context, *UserData) (*Exists, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckUserExists not implemented")
}
func (*UnimplementedAuthenticatorServer) VerifyUser(context.Context, *AuthReply) (*AuthReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyUser not implemented")
}
func (*UnimplementedAuthenticatorServer) RefreshToken(context.Context, *AuthReply) (*AuthReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RefreshToken not implemented")
}
func (*UnimplementedAuthenticatorServer) PublicUserToken(context.Context, *PublicUser) (*AuthReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PublicUserToken not implemented")
}
func (*UnimplementedAuthenticatorServer) GetPubKey(context.Context, *KeyID) (*PublicKey, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPubKey not implemented")
}
func (*UnimplementedAuthenticatorServer) ResetUserPW(context.Context, *UserEmail) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetUserPW not implemented")
}

func RegisterAuthenticatorServer(s *grpc.Server, srv AuthenticatorServer) {
	s.RegisterService(&_Authenticator_serviceDesc, srv)
}

func _Authenticator_RegisterPwUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegistrationData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthenticatorServer).RegisterPwUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authenticator.Authenticator/RegisterPwUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthenticatorServer).RegisterPwUser(ctx, req.(*RegistrationData))
	}
	return interceptor(ctx, in, info, handler)
}

func _Authenticator_AuthenticatePwUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserPassword)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthenticatorServer).AuthenticatePwUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authenticator.Authenticator/AuthenticatePwUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthenticatorServer).AuthenticatePwUser(ctx, req.(*UserPassword))
	}
	return interceptor(ctx, in, info, handler)
}

func _Authenticator_ChangeUserPw_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewUserPassword)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthenticatorServer).ChangeUserPw(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authenticator.Authenticator/ChangeUserPw",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthenticatorServer).ChangeUserPw(ctx, req.(*NewUserPassword))
	}
	return interceptor(ctx, in, info, handler)
}

func _Authenticator_CheckUserExists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthenticatorServer).CheckUserExists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authenticator.Authenticator/CheckUserExists",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthenticatorServer).CheckUserExists(ctx, req.(*UserData))
	}
	return interceptor(ctx, in, info, handler)
}

func _Authenticator_VerifyUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthReply)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthenticatorServer).VerifyUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authenticator.Authenticator/VerifyUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthenticatorServer).VerifyUser(ctx, req.(*AuthReply))
	}
	return interceptor(ctx, in, info, handler)
}

func _Authenticator_RefreshToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthReply)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthenticatorServer).RefreshToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authenticator.Authenticator/RefreshToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthenticatorServer).RefreshToken(ctx, req.(*AuthReply))
	}
	return interceptor(ctx, in, info, handler)
}

func _Authenticator_PublicUserToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublicUser)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthenticatorServer).PublicUserToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authenticator.Authenticator/PublicUserToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthenticatorServer).PublicUserToken(ctx, req.(*PublicUser))
	}
	return interceptor(ctx, in, info, handler)
}

func _Authenticator_GetPubKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KeyID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthenticatorServer).GetPubKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authenticator.Authenticator/GetPubKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthenticatorServer).GetPubKey(ctx, req.(*KeyID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Authenticator_ResetUserPW_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserEmail)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthenticatorServer).ResetUserPW(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authenticator.Authenticator/ResetUserPW",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthenticatorServer).ResetUserPW(ctx, req.(*UserEmail))
	}
	return interceptor(ctx, in, info, handler)
}

var _Authenticator_serviceDesc = grpc.ServiceDesc{
	ServiceName: "authenticator.Authenticator",
	HandlerType: (*AuthenticatorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterPwUser",
			Handler:    _Authenticator_RegisterPwUser_Handler,
		},
		{
			MethodName: "AuthenticatePwUser",
			Handler:    _Authenticator_AuthenticatePwUser_Handler,
		},
		{
			MethodName: "ChangeUserPw",
			Handler:    _Authenticator_ChangeUserPw_Handler,
		},
		{
			MethodName: "CheckUserExists",
			Handler:    _Authenticator_CheckUserExists_Handler,
		},
		{
			MethodName: "VerifyUser",
			Handler:    _Authenticator_VerifyUser_Handler,
		},
		{
			MethodName: "RefreshToken",
			Handler:    _Authenticator_RefreshToken_Handler,
		},
		{
			MethodName: "PublicUserToken",
			Handler:    _Authenticator_PublicUserToken_Handler,
		},
		{
			MethodName: "GetPubKey",
			Handler:    _Authenticator_GetPubKey_Handler,
		},
		{
			MethodName: "ResetUserPW",
			Handler:    _Authenticator_ResetUserPW_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "authenticator.proto",
}
